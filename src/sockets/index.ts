import { FastifyInstance } from 'fastify';
import WebSocket from 'ws';
import log from '@app/log';
import attackHandler from './handler.attack';
import connectionHandler from './handler.connection';
import shipPositionHandler from './handler.ship-positions';
import { OutgoingMsgType } from '@app/payloads/outgoing';
import { WsPayload, IncomingMsgType } from '@app/payloads/incoming';
import { WsPayloadSchema } from '@app/payloads/schemas';
import { MessageHandler, MessageHandlerResponse } from './common';
import { heartbeat, send } from './common';

// Used to track socket message processing. The server only supports
// processing a single message per user/socket at any given time
const sockLocks = new WeakMap<WebSocket, boolean>();

/**
 * Configures a heartbeat for the WSS attached to the given fastify instance.
 * @param app {FastifyInstance}
 */
export function configureHeartbeat(app: FastifyInstance) {
  heartbeat(app);
}

const MessageHandlers: { [key in IncomingMsgType]: MessageHandler<unknown> } = {
  [IncomingMsgType.Connection]: connectionHandler,
  [IncomingMsgType.ShipPositions]: shipPositionHandler,
  [IncomingMsgType.Attack]: attackHandler
};

/**
 * Find an appropriate handler for the incoming message, and execute it.
 * Send a response generated by the handler to the client.
 * @param ws {WebSocket}
 * @param data {WsPayload}
 */
async function _processSocketMessage(ws: WebSocket, data: WsPayload) {
  const handler = MessageHandlers[data.type];

  if (sockLocks.get(ws) === true) {
    send(ws, {
      type: OutgoingMsgType.PleaseWait,
      data: {
        info:
          'Already processing a message on your behalf. Slow down there kiddo!'
      }
    });
  } else if (handler) {
    log.trace('processing incoming message: %j', data);
    let resp!: MessageHandlerResponse<unknown>;

    // Lock the socket while we process this message
    sockLocks.set(ws, true);

    try {
      resp = await handler(ws, data.data);
    } catch (e) {
      log.error('error processing an incoming message: %j', data);
      log.error(e);
      resp = {
        type: OutgoingMsgType.ServerError,
        data: {
          info: e.toString()
        }
      };
    } finally {
      // Unlock the socket for processing future messages
      sockLocks.set(ws, false);
      // Send the response
      send(ws, resp);
    }
  } else {
    log.warn('received unknown message type: %j', data);
    send(ws, {
      type: OutgoingMsgType.BadMessageType,
      data: { info: `"${data.type}" is an unrecognised message type` }
    });
  }
}

/**
 * Validates an incoming WS payload, and forwards it for further processing.
 * @param ws {WebSocket}
 * @param data {WebSocket.Data}
 */
export default async function processSocketMessage(
  ws: WebSocket,
  data: WebSocket.Data
) {
  let parsed: WsPayload;

  try {
    parsed = JSON.parse(data.toString());
  } catch (error) {
    log.error('Received Malformed socket message JSON. Data was:\n%j', data);
    return;
  }

  const valid = WsPayloadSchema.validate(parsed);

  if (valid.error) {
    log.warn('client sent an invalid message payload: %j', parsed);
    log.warn('validation failed with the error(s): %j', valid.error);
    send(ws, {
      type: OutgoingMsgType.BadPayload,
      data: {
        info: 'Your payload was a bit iffy. K thx bye.'
      }
    });
  } else {
    _processSocketMessage(ws, valid.value as WsPayload);
  }
}
