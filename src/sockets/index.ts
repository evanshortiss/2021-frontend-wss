import { FastifyInstance } from 'fastify';
import WebSocket from 'ws';
import log from '@app/log';
import attackHandler from './handler.attack';
import connectionHandler from './handler.connection';
import shipPositionHandler from './handler.ship-positions';
import { OutgoingMsgType } from '@app/payloads/outgoing';
import { WsPayload, IncomingMsgType } from '@app/payloads/incoming';
import {
  AttackPayloadSchema,
  ConnectionRequestPayloadSchema,
  ShipsLockedPayloadSchema,
  WsPayloadSchema
} from '@app/payloads/schemas';
import { isLockedSocket, lockSock, MessageHandler, unlockSock } from './common';
import { heartbeat, send } from './common';
import Joi from 'joi';
import { NODE_ENV } from '@app/config';

type MessageHandlersContainer = {
  [key in IncomingMsgType]: {
    schema: Joi.Schema;
    fn: MessageHandler<any, any>;
  };
};

/**
 * Configures a heartbeat for the WSS attached to the given fastify instance.
 * @param app {FastifyInstance}
 */
export function configureHeartbeat(app: FastifyInstance) {
  heartbeat(app);
}

const MessageHandlers: MessageHandlersContainer = {
  [IncomingMsgType.Connection]: {
    fn: connectionHandler,
    schema: ConnectionRequestPayloadSchema
  },
  [IncomingMsgType.ShipPositions]: {
    fn: shipPositionHandler,
    schema: ShipsLockedPayloadSchema
  },
  [IncomingMsgType.Attack]: {
    fn: attackHandler,
    schema: AttackPayloadSchema
  }
};

/**
 * Find an appropriate handler for the incoming message, and execute it.
 *
 * Handlers are only executed if we're not already processing a message for
 * the WebSocket in question.
 *
 * Sends the response generated by the handler to the client and unlocks
 * the WebSocket to support processing future messages.
 *
 * @param ws {WebSocket}
 * @param payload {WsPayload}
 */
async function _processSocketMessage(ws: WebSocket, payload: WsPayload) {
  const handler = MessageHandlers[payload.type];

  if (handler) {
    log.trace('processing incoming message: %j', payload);
    const validation = handler.schema.validate(payload.data, {
      stripUnknown: true,
      abortEarly: false
    });

    if (validation.error) {
      throw validation.error;
    } else {
      return handler.fn(ws, validation.value);
    }
  } else {
    throw new HandlerNotFoundError(payload.type);
  }
}

/**
 * Validates an incoming WS payload, and forwards it for further processing.
 * @param ws {WebSocket}
 * @param data {WebSocket.Data}
 */
export default async function processSocketMessage(
  ws: WebSocket,
  data: WebSocket.Data
) {
  if (isLockedSocket(ws)) {
    log.warn(
      "client sent a message, but we're already processing one on their behalf"
    );
    send(ws, {
      type: OutgoingMsgType.PleaseWait,
      data: {
        info:
          'Already processing a message on your behalf. Slow down there kiddo!'
      }
    });
  } else {
    log.trace(`processing incoming socket data: ${data.toString()}`);

    // Lock the socket mutex. Any new messages received from a client will be
    // ignored until we finish processing the current message.
    lockSock(ws);

    Promise.resolve(data)
      .then((data) => JSON.parse(data.toString()))
      .then((json) => {
        const valid = WsPayloadSchema.validate(json, {
          stripUnknown: true,
          abortEarly: false
        });

        if (valid.error) {
          throw valid.error;
        } else {
          return valid.value;
        }
      })
      .then((payload: WsPayload) => _processSocketMessage(ws, payload))
      .then((result) => send(ws, result))
      .catch((e) => {
        if (e instanceof SyntaxError) {
          log.error(
            'received malformed socket message JSON/Buffer. Buffer contained:\n%j',
            data.toString()
          );
          send(ws, {
            type: OutgoingMsgType.BadPayload,
            data: {
              info: 'Your payload was a bit iffy. K thx bye.'
            }
          });
        } else if (e instanceof Joi.ValidationError) {
          log.warn(
            `message failed schema validation with reason "${
              e.message
            }": ${data.toString()}`
          );
          send(ws, {
            type: OutgoingMsgType.BadPayload,
            data: {
              info: e.message
            }
          });
        } else if (e instanceof HandlerNotFoundError) {
          send(ws, {
            type: OutgoingMsgType.BadMessageType,
            data: {
              info: `"${e.type}" is an unrecognised message type`
            }
          });
        } else {
          log.error(`error processing an incoming message: ${data.toString()}`);
          log.error(e);
          send(ws, {
            type: OutgoingMsgType.ServerError,
            data: {
              info:
                NODE_ENV == 'dev'
                  ? e.toString()
                  : 'there was an error processing your payload'
            }
          });
        }
      })
      .finally(() => {
        // Lift the mutex so the client can send more messages to the server
        unlockSock(ws);
      });
  }
}

class HandlerNotFoundError extends Error {
  constructor(public type: string) {
    super();
  }
}
